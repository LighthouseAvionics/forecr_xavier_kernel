// // SPDX-License-Identifier: GPL-2.0-only
// // SPDX-FileCopyrightText: Copyright (c) 2018-2023, NVIDIA CORPORATION & AFFILIATES. All rights reserved.

// /dts-v1/;
// /plugin/;

// // #include <dt-bindings/clock/tegra234-clock.h>
// // #include <dt-bindings/gpio/tegra234-gpio.h>
// // #include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
// #include <overlay/imx412_modes.dtsi>

// #define CAM0_RST_L	TEGRA234_MAIN_GPIO(H, 3)

// /* camera control gpio definitions */
// / {
// 	overlay-name = "Jetson Camera IMX477";
// 	jetson-header-name = "Jetson AGX CSI Connector";
// 	compatible = JETSON_COMPATIBLE;

// 	fragment@0 {
// 		target-path = "/";

// 		__overlay__ {
// 			tegra-capture-vi {
// 				// 2 channels for cameras 0 and 1
// 				// will be 6 later for 6 cameras
// 				num-channels = <2>;
// 				ports {
// 					#address-cells = <1>;
// 					#size-cells = <0>;
// 					port@0 {
// 						reg = <0>;
// 						liimx477_vi_in0: endpoint {
// 							port-index = <0>;
// 							bus-width = <2>;
// 							remote-endpoint = <&liimx477_csi_out0>;
// 						};
// 					};
// 					port@1 {
// 						reg = <1>;
// 						liimx477_vi_in1: endpoint {
// 							port-index = <1>;
// 							bus-width = <2>;
// 							remote-endpoint = <&liimx477_csi_out1>;
// 						};
// 					};
// 				};

// 			tegra-camera-platform {
// 				num_csi_lanes = <16>;
// 				max_lane_speed = <2000000>;
// 				min_bits_per_pixel = <10>;
// 				vi_peak_byte_per_pixel = <2>;
// 				vi_bw_margin_pct = <25>;
// 				max_pixel_rate = <7500000>;
// 				isp_peak_byte_per_pixel = <5>;
// 				isp_bw_margin_pct = <25>;
// 				modules{
// 					status = "okay";
// 					modules {
// 						module0 {
// 							badge = "imx477_bottomleft_liimx477";
// 							position = "bottomleft";
// 							orientation = "0";
// 							status = "okay";
// 							drivernode0 {
// 								/* Declare PCL support driver (classically known as guid)  */
// 								pcl_id = "v4l2_sensor";
// 								/* Driver v4l2 device name */
// 								devname = "imx477 30-001a";
// 								/* Declare the device-tree hierarchy to driver instance */
// 								proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@0/imx477_a@1a";
// 							};
// 						};
// 						module1 {
// 							badge = "imx477_bottomright_liimx477";
// 							position = "bottomright";
// 							orientation = "0";
// 							status = "okay";
// 							drivernode0 {
// 								/* Declare PCL support driver (classically known as guid)  */
// 								pcl_id = "v4l2_sensor";
// 								/* Driver v4l2 device name */
// 								devname = "imx477 31-001a";
// 								/* Declare the device-tree hierarchy to driver instance */
// 								proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@1/imx477_b@1a";
// 							};
// 						};
// 				}
// 			}
// 			/* 
// 			// tegra-camera-platform {
// 			// 	modules {
// 			// 		status = "okay";
// 			// 		module0 {
// 			// 			badge = "imx390_rear";
// 			// 			position = "rear";
// 			// 			orientation = "1";
// 			// 			status = "okay";
// 			// 			drivernode0 {
// 			// 				status = "okay";
// 			// 				/* Declare PCL support driver (classically known as guid) */
// 			// 				pcl_id = "v4l2_sensor";
// 			// 				/* Declare the device-tree hierarchy to driver instance */
// 			// 				sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/imx390_a@1b";
// 			// 			};
// 			// 		};
// 			// 		module1 {
// 			// 			status = "okay";
// 			// 			badge = "imx390_front";
// 			// 			position = "front";
// 			// 			orientation = "1";
// 			// 			drivernode0 {
// 			// 				status = "okay";
// 			// 				/* Declare PCL support driver (classically known as guid)  */
// 			// 				pcl_id = "v4l2_sensor";
// 			// 				/* Declare the device-tree hierarchy to driver instance */
// 			// 				sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/imx390_b@1c";
// 			// 			};
// 			// 		};
// 			// 	};
// 			// };
// 			*/

// 			bus@0{
// 				host1x@13e00000 {
// 					nvcsi@15a00000 {
// 						num-channels = <2>;
// 						channel@0 {
// 							status = "okay";
// 							ports {
// 								#address-cells = <1>;
// 								#size-cells = <0>;
// 								status = "okay";
// 								port@0 {
// 									status = "okay";
// 									reg = <0>;
// 									liimx477_csi_in0: endpoint@0 {
// 										status = "okay";
// 										port-index = <0>;
// 										bus-width = <2>;
// 										remote-endpoint = <&liimx477_csi_out0>;
// 									};
// 								};
// 								port@1 {
// 									status = "okay";
// 									reg = <1>;

// 									liimx477_csi_out0: endpoint@1 {
// 										status = "okay";
// 										remote-endpoint = <&liimx477_vi_in0>;
// 									};
// 								};
// 							};
// 						};
// 						channel@1 {
// 							status = "okay";
// 							ports {
// 								#address-cells = <1>;
// 								#size-cells = <0>;
// 								status = "okay";
// 								port@0 {
// 									status = "okay";
// 									reg = <0>;
// 									liimx477_csi_in1: endpoint@2 {
// 										status = "okay";
// 										port-index = <0>;
// 										bus-width = <2>;
// 										remote-endpoint = <&liimx477_csi_out1>;
// 									};
// 								};
// 								port@1 {
// 									status = "okay";
// 									reg = <1>;
// 									liimx477_csi_out1: endpoint@3 {
// 										status = "okay";
// 										remote-endpoint = <&liimx477_vi_in1>;
// 									};
// 								};
// 							};
// 						};
// 					};

// 					i2c@3180000 {
// 						imx477_a@1a {
// 							compatible = "sony,imx477";
			
// 							reg = <0x1a>;
// 							devnode = "video0";
			
// 							/* Physical dimensions of sensor */
// 							physical_w = "15.0";
// 							physical_h = "12.5";
			
// 							sensor_model ="imx477";
// 							/* Define any required hw resources needed by driver */
// 							/* ie. clocks, io pins, power sources */
			
// 							/* Defines number of frames to be dropped by driver internally after applying */
// 							/* sensor crop settings. Some sensors send corrupt frames after applying */
// 							/* crop co-ordinates */
// 							//post_crop_frame_drop = "0";
			
// 							/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
// 							//use_decibel_gain = "true";
			
// 							/* if true, delay gain setting by one frame to be in sync with exposure */
// 							//delayed_gain = "true";
			
// 							/* enable CID_SENSOR_MODE_ID for sensor modes selection */
// 							use_sensor_mode_id = "true";

// 							mode0 = <&imx477_mode0>;
// 							mode1 = <&imx477_mode1>;
// 							mode2 = <&imx477_mode2>;
// 							mode3 = <&imx477_mode3>;
// 							mode4 = <&imx477_mode4>;


// 					};
// 				};
// 			};

				

			
			
// 			bus@0{
// 				host1x@13e00000 {
// 					nvcsi@15a00000 {
// 						num-channels = <2>;
// 						channel@0 {
// 							status = "okay";
// 							reg = <0>;
// 							ports {
// 								status = "okay";
// 								port@0 {
// 									status = "okay";
// 									imx390_csi_in0: endpoint@0 {
// 										status = "okay";
// 										port-index = <0>;
// 										bus-width = <2>;
// 										remote-endpoint = <&imx390_imx390_out0>;
// 									};
// 								};
// 								port@1 {
// 									status = "okay";
									
// 									imx390_csi_out0: endpoint@1 {
// 										status = "okay";
// 										remote-endpoint = <&imx390_vi_in0>;
// 									};
// 								};
// 							};
// 						};
// 						channel@1 {
// 							status = "okay";
// 							ports {
// 								status = "okay";
// 								port@0 {
// 									status = "okay";
// 									imx390_csi_in1: endpoint@2 {
// 										status = "okay";
// 										port-index = <0>;
// 										bus-width = <2>;
// 										remote-endpoint = <&imx390_imx390_out1>;
// 									};
// 								};
// 								port@1 {
// 									status = "okay";
// 									imx390_csi_out1: endpoint@3 {
// 										status = "okay";
// 										remote-endpoint = <&imx390_vi_in1>;
// 									};
// 								};
// 							};
// 						};
// 					};
// 				};
// 				i2c@3180000 {
// 					tca9546@70 {
// 						status = "okay";
// 						compatible = "nxp,pca9546";
// 						reg = <0x70>;
// 						#address-cells = <1>;
// 						#size-cells = <0>;
// 						skip_mux_detect = "yes";
// 						i2c@0 {
// 							reg = <0>;
// 							i2c-mux,deselect-on-exit;
// 							#address-cells = <1>;
// 							#size-cells = <0>;
// 							status = "okay";
// 							dser: max9296@48 {
// 								status = "okay";
// 								compatible = "maxim,max9296";
// 								reg = <0x48>;
// 								csi-mode = "2x4";
// 								max-src = <2>;
// 								reset-gpios = <&gpio CAM0_RST_L GPIO_ACTIVE_HIGH>;
// 							};
// 							ser_prim: max9295_prim@62 {
// 								status = "okay";
// 								compatible = "maxim,max9295";
// 								reg = <0x62>;
// 								is-prim-ser;
// 							};
// 							ser_a: max9295_a@40 {
// 								status = "okay";
// 								compatible = "maxim,max9295";
// 								reg = <0x40>;
// 								nvidia,gmsl-dser-device = <&dser>;
// 							};
// 							ser_b: max9295_b@60 {
// 								status = "okay";
// 								compatible = "maxim,max9295";
// 								reg = <0x60>;
// 								nvidia,gmsl-dser-device = <&dser>;
// 							};
// 							imx390_a@1b {
// 								status = "okay";
// 								def-addr = <0x1a>;
// 								/* Define any required hw resources needed by driver */
// 								/* ie. clocks, io pins, power sources */
// 								clocks = <&bpmp TEGRA234_CLK_EXTPERIPH1>,
// 									<&bpmp TEGRA234_CLK_EXTPERIPH1>;
// 								clock-names = "extperiph1", "pllp_grtba";
// 								mclk = "extperiph1";
// 								nvidia,gmsl-ser-device = <&ser_a>;
// 								nvidia,gmsl-dser-device = <&dser>;
// 								ports {
// 									status = "okay";
// 									port@0 {
// 										status = "okay";
// 										imx390_imx390_out0: endpoint {
// 											status = "okay";
// 											vc-id = <0>;
// 											port-index = <0>;
// 											bus-width = <2>;
// 											remote-endpoint = <&imx390_csi_in0>;
// 										};
// 									};
// 								};
// 							};
// 							imx390_b@1c {
// 								status = "okay";
// 								def-addr = <0x1a>;
// 								/* Define any required hw resources needed by driver */
// 								/* ie. clocks, io pins, power sources */
// 								clocks = <&bpmp TEGRA234_CLK_EXTPERIPH1>,
// 									<&bpmp TEGRA234_CLK_EXTPERIPH1>;
// 								clock-names = "extperiph1", "pllp_grtba";
// 								mclk = "extperiph1";
// 								nvidia,gmsl-ser-device = <&ser_b>;
// 								nvidia,gmsl-dser-device = <&dser>;
// 								ports {
// 									status = "okay";
// 									port@0 {
// 										status = "okay";
// 										imx390_imx390_out1: endpoint {
// 											status = "okay";
// 											vc-id = <1>;
// 											port-index = <0>;
// 											bus-width = <2>;
// 											remote-endpoint = <&imx390_csi_in1>;
// 										};
// 									};
// 								};
// 							};
// 						};
// 					};
// 				};
// 			};
// 		};
// 	};
// };


/*
 * Copyright (C) 2022, Leopardimaging Inc.
 * Based on Copyright (c) 2016-2022, NVIDIA CORPORATION.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

 / {
	tegra-capture-vi {
		num-channels = <6>;
		ports {
			#address-cells = <1>;
			#size-cells = <0>;
			port@0 {
				reg = <0>;
				liimx477_vi_in0: endpoint {
					port-index = <0>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out0>;
				};
			};
			port@1 {
				reg = <1>;
				liimx477_vi_in1: endpoint {
					port-index = <1>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out1>;
				};
			};
			port@2 {
				reg = <2>;
				liimx477_vi_in2: endpoint {
					port-index = <2>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out2>;
				};
			};
			port@3 {
				reg = <3>;
				liimx477_vi_in3: endpoint {
					port-index = <3>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out3>;
				};
			};
			port@4 {
				reg = <4>;
				liimx477_vi_in4: endpoint {
					port-index = <4>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out4>;
				};
			};
			port@5 {
				reg = <5>;
				liimx477_vi_in5: endpoint {
					port-index = <5>;
					bus-width = <2>;
					remote-endpoint = <&liimx477_csi_out5>;
				};
			};
		};
	};

	bus@0{
		host1x@13e00000 {
			nvcsi@15a00000 {
				num-channels = <6>;
				#address-cells = <1>;
				#size-cells = <0>;
				channel@0 {
					reg = <0>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in0: endpoint@0 {
								port-index = <0>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out0>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out0: endpoint@1 {
								remote-endpoint = <&liimx477_vi_in0>;
							};
						};
					};
				};
				channel@1 {
					reg = <1>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in1: endpoint@2 {
								port-index = <1>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out1>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out1: endpoint@3 {
								remote-endpoint = <&liimx477_vi_in1>;
							};
						};
					};
				};
				channel@2 {
					reg = <2>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in2: endpoint@4 {
								port-index = <2>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out2>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out2: endpoint@5 {
								remote-endpoint = <&liimx477_vi_in2>;
							};
						};
					};
				};
				channel@3 {
					reg = <3>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in3: endpoint@6 {
								port-index = <3>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out3>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out3: endpoint@7 {
								remote-endpoint = <&liimx477_vi_in3>;
							};
						};
					};
				};
				channel@4 {
					reg = <4>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in4: endpoint@8 {
								port-index = <4>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out4>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out4: endpoint@9 {
								remote-endpoint = <&liimx477_vi_in4>;
							};
						};
					};
				};
				channel@5 {
					reg = <5>;
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_csi_in5: endpoint@10 {
								port-index = <5>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_imx477_out5>;
							};
						};
						port@1 {
							reg = <1>;
							liimx477_csi_out5: endpoint@11 {
								remote-endpoint = <&liimx477_vi_in5>;
							};
						};
					};
				};
			};
		};

		i2c@3180000 {
			tca9548@70 {
				i2c@0 {
				imx477_a@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video0";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_a";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_a";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 22x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_a";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 22x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_a";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 120.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 60.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};

					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out0: endpoint {
								port-index = <0>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in0>;
								};
							};
						};
					};
				};
				i2c@1 {
				imx477_b@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video1";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_b";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_b";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_b";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_b";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 120.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 60.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out1: endpoint {
								port-index = <1>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in1>;
								};
							};
						};
					};
				};
				i2c@2 {
				imx477_c@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video2";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_c";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_c";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 22x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_c";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_c";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 120.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 60.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out2: endpoint {
								port-index = <2>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in2>;
								};
							};
						};
					};
				};

				i2c@3 {
				imx477_d@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video3";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_d";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_d";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_d";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_d";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 120.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 60.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out3: endpoint {
								port-index = <3>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in3>;
								};
							};
						};
					};
				};

				i2c@4 {
				imx477_e@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video4";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_e";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_e";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_e";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_e";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 120.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 60.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out4: endpoint {
								port-index = <4>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in4>;
								};
							};
						};
					};
				};

				i2c@5 {
				imx477_g@1a {
					compatible = "sony,imx477";

					reg = <0x1a>;
					devnode = "video5";

					/* Physical dimensions of sensor */
					physical_w = "15.0";
					physical_h = "12.5";

					sensor_model ="imx477";
					/* Define any required hw resources needed by driver */
					/* ie. clocks, io pins, power sources */

					/* Defines number of frames to be dropped by driver internally after applying */
					/* sensor crop settings. Some sensors send corrupt frames after applying */
					/* crop co-ordinates */
					//post_crop_frame_drop = "0";

					/* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
					//use_decibel_gain = "true";

					/* if true, delay gain setting by one frame to be in sync with exposure */
					//delayed_gain = "true";

					/* enable CID_SENSOR_MODE_ID for sensor modes selection */
					use_sensor_mode_id = "true";

					/* WAR to prevent banding by reducing analog gain. Bug 2229902 */
					//limit_analog_gain = "true";

					/**
					* ==== Modes ====
					* A modeX node is required to support v4l2 driver
					* implementation with NVIDIA camera software stack
					*
					* == Signal properties ==
					*
					* phy_mode = "";
					* PHY mode used by the MIPI lanes for this device
					*
					* tegra_sinterface = "";
					* CSI Serial interface connected to tegra
					* Incase of virtual HW devices, use virtual
					* For SW emulated devices, use host
					*
					* pix_clk_hz = "";
					* Sensor pixel clock used for calculations like exposure and framerate
					*
					* readout_orientation = "0";
					* Based on camera module orientation.
					* Only change readout_orientation if you specifically
					* Program a different readout order for this mode
					*
					* == Image format Properties ==
					*
					* active_w = "";
					* Pixel active region width
					*
					* active_h = "";
					* Pixel active region height
					*
					* pixel_t = "";
					* The sensor readout pixel pattern
					*
					* line_length = "";
					* Pixel line length (width) for sensor mode.
					*
					* == Source Control Settings ==
					*
					* Gain factor used to convert fixed point integer to float
					* Gain range [min_gain/gain_factor, max_gain/gain_factor]
					* Gain step [step_gain/gain_factor is the smallest step that can be configured]
					* Default gain [Default gain to be initialized for the control.
					*     use min_gain_val as default for optimal results]
					* Framerate factor used to convert fixed point integer to float
					* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
					* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
					* Default Framerate [Default framerate to be initialized for the control.
					*     use max_framerate to get required performance]
					* Exposure factor used to convert fixed point integer to float
					* For convenience use 1 sec = 1000000us as conversion factor
					* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
					* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
					* Default Exposure Time [Default exposure to be initialized for the control.
					*     Set default exposure based on the default_framerate for optimal exposure settings]
					*
					* gain_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_gain_val = ""; (ceil to integer)
					* max_gain_val = ""; (ceil to integer)
					* step_gain_val = ""; (ceil to integer)
					* default_gain = ""; (ceil to integer)
					* Gain limits for mode
					*
					* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_exp_time = ""; (ceil to integer)
					* max_exp_time = ""; (ceil to integer)
					* step_exp_time = ""; (ceil to integer)
					* default_exp_time = ""; (ceil to integer)
					* Exposure Time limits for mode (sec)
					*
					* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
					* min_framerate = ""; (ceil to integer)
					* max_framerate = ""; (ceil to integer)
					* step_framerate = ""; (ceil to integer)
					* default_framerate = ""; (ceil to integer)
					* Framerate limits for mode (fps)
					*
					* embedded_metadata_height = "";
					* Sensor embedded metadata height in units of rows.
					* If sensor does not support embedded metadata value should be 0.
					*/
					mode0 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_g";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "4056";
						active_h = "3040";
						readout_orientation = "0";
						line_length = "9024";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "419200000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					mode1 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_g";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "3840";
						active_h = "2160";
						readout_orientation = "0";
						line_length = "11200";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "30000000"; /* 30.0 fps */
						step_framerate = "1";
						default_framerate = "30000000"; /* 30.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode2 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_g";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1080";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "80";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "356"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "2000000"; /* 2.0 fps */
						max_framerate = "60000000"; /* 60.0 fps */
						step_framerate = "1";
						default_framerate = "60000000"; /* 60.0 fps */
						min_exp_time = "13"; /* us */
						max_exp_time = "683709"; /* us */
						step_exp_time = "1";
						default_exp_time = "2495"; /* us */

						embedded_metadata_height = "2";
					};
					mode3 {
						mclk_khz = "24000";
						num_lanes = "2";
						tegra_sinterface = "serial_g";
						phy_mode = "DPHY";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "10";
						csi_pixel_bit_depth = "10";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "2028";
						active_h = "1520";
						readout_orientation = "0";
						line_length = "7000";
						inherent_gain = "1";
						mclk_multiplier = "18";
						pix_clk_hz = "300000000";

						gain_factor = "16";
						framerate_factor = "1000000";
						exposure_factor = "1000000";
						min_gain_val = "16"; /* 1.00x */
						max_gain_val = "256"; /* 16x */
						step_gain_val = "1";
						default_gain = "16"; /* 1.00x */
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1000000"; /* 2.0 fps */
						max_framerate = "27000000"; /* 27.0 fps */
						step_framerate = "1";
						default_framerate = "27000000"; /* 27.0 fps */
						min_exp_time = "16"; /* us */
						max_exp_time = "16666"; /* us */
						step_exp_time = "1";
						default_exp_time = "16666"; /* us */
						embedded_metadata_height = "2";
					};
					ports {
						#address-cells = <1>;
						#size-cells = <0>;
						port@0 {
							reg = <0>;
							liimx477_imx477_out5: endpoint {
								port-index = <5>;
								bus-width = <2>;
								remote-endpoint = <&liimx477_csi_in5>;
								};
							};
						};
					};
				};
			};
		};
	};
};

/ {

	tegra-camera-platform {
		compatible = "nvidia, tegra-camera-platform";
		/**
		* Physical settings to calculate max ISO BW
		*
		* num_csi_lanes = <>;
		* Total number of CSI lanes when all cameras are active
		*
		* max_lane_speed = <>;
		* Max lane speed in Kbit/s
		*
		* min_bits_per_pixel = <>;
		* Min bits per pixel
		*
		* vi_peak_byte_per_pixel = <>;
		* Max byte per pixel for the VI ISO case
		*
		* vi_bw_margin_pct = <>;
		* Vi bandwidth margin in percentage
		*
		* max_pixel_rate = <>;
		* Max pixel rate in Kpixel/s for the ISP ISO case
		*
		* isp_peak_byte_per_pixel = <>;
		* Max byte per pixel for the ISP ISO case
		*
		* isp_bw_margin_pct = <>;
		* Isp bandwidth margin in percentage
		*/
		num_csi_lanes = <16>;
		max_lane_speed = <2000000>;
		min_bits_per_pixel = <10>;
		vi_peak_byte_per_pixel = <2>;
		vi_bw_margin_pct = <25>;
		max_pixel_rate = <7500000>;
		isp_peak_byte_per_pixel = <5>;
		isp_bw_margin_pct = <25>;

		/**
		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
		 * The first part is the camera_board_id for the module; if the module is in a FFD
		 * platform, then use the platform name for this part.
		 * The second part contains the position of the module, ex. "rear" or "front".
		 * The third part contains the last 6 characters of a part number which is found
		 * in the module's specsheet from the vender.
		 */
		modules {
			module0 {
				badge = "imx477_bottomleft_liimx477";
				position = "bottomleft";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 9-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@0/imx477_a@1a";
				};
			};
			module1 {
				badge = "imx477_bottomright_liimx477";
				position = "bottomright";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 10-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@1/imx477_b@1a";
				};
			};
			module2 {
				badge = "imx477_centerleft_liimx477";
				position = "centerleft";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 11-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@2/imx477_c@1a";
				};
			};
			module3 {
				badge = "imx477_centerright_liimx477";
				position = "centerright";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 12-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@3/imx477_d@1a";
				};
			};
			module4 {
				badge = "imx477_topright_liimx477";
				position = "topright";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 13-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@4/imx477_e@1a";
				};
			};
			module5 {
				badge = "imx477_topleft_liimx477";
				position = "topleft";
				orientation = "0";
				drivernode0 {
					/* Declare PCL support driver (classically known as guid)  */
					pcl_id = "v4l2_sensor";
					/* Driver v4l2 device name */
					devname = "imx477 14-001a";
					/* Declare the device-tree hierarchy to driver instance */
					proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tca9548@70/i2c@5/imx477_g@1a";
				};
			};
		};
	};
};

